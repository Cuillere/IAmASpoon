var logger = require('logger');

//BODY
exports.Body = function Body(x, y, width, height, mass) {
	//can either be platform, player, projectile
	this.group = 'platform';
	this.mass = mass;
	this.forces = [];
	this.forces.push({name:'weight', force:new exports.Force(0, mass)});
	this.x = x;
	this.y = y;
	this.width = width;
	this.height = height;
	this.xSpeed = 0;
	this.ySpeed = 0;
	this.xAcceleration = 0;
	this.yAcceleration = 0;
	this.xFriction = 0;
	this.yFriction = 0;
	this.isFixed = false;
}

exports.Body.prototype = {
	onCollide: function(body, excessX, excessY) {
		if(!this.isFixed) {
			this.x -= excessX;
			this.y -= excessY;
		}
	},

	setGroup: function(group) {
		if(group == 'player' || group == 'platform' || group == 'projectile') {
			this.group = group;
		} else {
			logger.log('Can\'t set'+ '\'' + group + '\'' + ' as group.' )
		}
	},

	tick: function(elapsedTime) {
		if(!this.isFixed) {
			var x = 0;
			var y = 0;
			this.forces.forEach(function(element, index, array){
				x += element.force.x;
				y += element.force.y;
			});
			this.xAcceleration = ((x * (elapsedTime/1000)) - this.xFriction);
			this.yAcceleration = ((y * (elapsedTime/1000)) - this.yFriction);
			this.xSpeed += this.xAcceleration;
			this.ySpeed += this.yAcceleration;
			this.xFriction = this.xSpeed*0.05;
			this.yFriction = this.ySpeed*0.05;
			this.x += this.xSpeed;
			this.y += this.ySpeed;
		}
	},

	addForce: function(name, force) {
		this.forces.push({name:name, force:force});
	},

	removeForce: function(name) {
		var indexToRemove = -1;
		this.forces.forEach(function(element, index, array) {
			if(element.name == name) {
				indexToRemove = index;
			}
		});
		if(indexToRemove >= 0) {
			this.forces.splice(indexToRemove, 1);
		}
	},

	getForce: function(name) {
		this.forces.forEach(function(element, index, array) {
			if(element.name == name) {
				return element.force;
			}
		});
	},

	sumAllForces: function() {
		var sum = new exports.Force(0,0);
		this.forces.forEach(function(element, index, array) {
			sum.add(element.force);
		});
		return sum;
	}
}

//FORCE
exports.Force = function Force(x, y) {
	this.x = x;
	this.y = y;
}

exports.Force.prototype = {
	add: function(force) {
		this.x += force.x;
		this.y += force.y;
	}
}

//PHYSIC-SPACE
exports.PhysicSpace = function PhysicSpace() {
	this.bodies = [];
}

exports.PhysicSpace.prototype = {
	addBody: function(id, body) {
		this.bodies.push({id:id, body:body});
	},

	removeBody: function(id) {
		var indexToRemove = -1;
		this.bodies.forEach(function(element, index, array) {
			if(element.id == id) {
				indexToRemove = index;
			}
		});
		if(indexToRemove >= 0) {
			this.bodies.splice(indexToRemove, 1);
		}
	},

	testCollisions: function() {
		var self = this;
		self.bodies.forEach(function(element, index, array) {
			var cur = element;
			var curBody = cur.body;
			self.bodies.forEach(function(element, index, array) {
				if(element != cur) {
					var excessX = 0;
					var excessY = 0;
					//Test collision between 'cur' and 'element'
					var body = element.body;

					if((body.group == 'player' && curBody.group == 'platform') || (body.group == 'platform' && curBody.group == 'player')) {
						if((body.x <= curBody.x && curBody.x <= body.x+body.width) 
							|| (body.x <= curBody.x+curBody.width && curBody.x+curBody.width <= body.x+body.width)) {
							if((body.y <= curBody.y && curBody.y <= body.y+body.height) 
								|| (body.y <= curBody.y+curBody.height && curBody.y+curBody.height <= body.y+body.height)) {
								//Collision ! 
								// /!\ A body can pass through another one if it is too speedy
								var force = curBody.sumAllForces();
								var excessX = 0;
								var excessY = 0;

								//Math.min(right, left)
								var excessXRight = curBody.x + curBody.width - body.x;
								var excessXLeft = -(body.x + body.width - curBody.x);
								if(Math.abs(excessXRight) < Math.abs(excessXLeft)){
									excessX = excessXRight;
								} else {
									excessX = excessXLeft;
								}
							
								//Math.min(bottom, top)
								var excessYBottom = curBody.y + curBody.height - body.y;
								var excessYTop = -(body.y + body.height - curBody.y);
								if(Math.abs(excessYBottom) < Math.abs(excessYTop)){
									excessY = excessYBottom;
								} else {
									excessY = excessYTop;
								}
									
								if(Math.abs(excessX) < Math.abs(excessY)) {
									excessY = 0;
								} else {
									excessX = 0;
								}
								curBody.onCollide(body, excessX, excessY);
								body.onCollide(curBody, -excessX, -excessY);
							}		
						}
					}
				}
			});
		});
	}

}











