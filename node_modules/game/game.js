var PhysicSpace = require('physics/physicSpace');
var Force = require('physics/force');
var Body = require('physics/body');
var logger = require('logger');
var Player = require('game/player');
var Flag = require('game/ctf/flag');


var physicSpace = new PhysicSpace();
var running = false;
var LOOP_TICK_TIME = 24;

exports.settings = null; //game settings, see server.conf file
exports.platforms = []; //body array
exports.players = [];   //player array
exports.projectiles = []; //body array
exports.spawns = []; //team, x, y array
exports.flags = []; //body, team, x, y
exports.flagSpawns = []; //team, x, y

exports.start = function(loopCallback) {
	this.running = true;
	exports.loop(loopCallback);
};

exports.loop = function(loopCallback) {
	if(this.running) {

        // /!\ Order is important :
        //1. tick players -> remove 'reaction' force
        //2. test collisions -> add 'reaction' force
        //3. tick projectiles -> if player is on the ground, add good speed thanks to 'reaction' force
        exports.players.forEach(function(element, index, array) {
			element.tick(LOOP_TICK_TIME, exports);
            if(element.health <= 0) {
                element.die();
            }
		});
        physicSpace.testCollisions(exports);
        exports.projectiles.forEach(function(element, index, array) {
            element.tick(LOOP_TICK_TIME);
        });
        loopCallback(exports.players, exports.projectiles, exports.flags, LOOP_TICK_TIME);
	}

	setTimeout(function() {
		exports.loop(loopCallback);
	}, LOOP_TICK_TIME);
};

exports.setSpawn = function(spawn) {
    this.spawns.push(spawn);
};

exports.pause = function() {
	this.running = false;
};

exports.resume = function() {
	this.running = true;
};

exports.stop = function() {
	this.running = false;
};

exports.addFlag = function(team, x, y) {
    var body = new Body(team, x, y, 50, 160, 0 * exports.settings.gravity);
    body.setGroup('flag');
    physicSpace.addBody(body);
    var flag = new Flag(team, x, y, body);
    this.flagSpawns.push({team:team, x:x, y:y});
    this.flags.push(flag);
};

exports.getFlag = function(id) {
    var flag;
    exports.flags.forEach(function(element, index, array) {
        if(element.team == id) {
            flag = element;
        }
    });
    return flag;
};

exports.spawnFlag = function(flag) {
    this.flagSpawns.forEach(function(element, index, array) {
        if(element.team == flag.team) {
            flag.body.x = element.x;
            flag.body.y = element.y;
            flag.isAtSpawn = true;
        }
    });
};

exports.addPlatform = function(id, x, y, width, height) {
	var body = new Body(id, x, y, width, height, 0 * exports.settings.gravity);
	body.setGroup('platform');
	physicSpace.addBody(body);
	body.isFixed = true;
    exports.platforms.push(body);
};

exports.addPlayer = function(id) {
	var body = new Body(id, 0, 0, 50, 80, 2 * exports.settings.gravity);
	body.setGroup('player');
	physicSpace.addBody(body);
    var player = new Player(id, body);
    player.respawnDelay = exports.settings.respawn_delay;
    exports.players.push(player);
    return player;
};

exports.getPlayer = function(id) {
    var player;
    exports.players.forEach(function(element, index, array) {
        if(element.id == id) {
            player = element;
        }
    });
    return player;
};

exports.removePlayer = function(id) {
	physicSpace.removeBody(id);
	var indexToRemove = -1;
    exports.players.forEach(function(element, index, array) {
		if(element.id == id) {
			indexToRemove = index;
		}
	});
	if(indexToRemove >= 0) {
        exports.players.splice(indexToRemove, 1);
	}
};

exports.addProjectile = function(projectile) {
    exports.projectiles.push(projectile);
    physicSpace.addBody(projectile.body);
};

exports.getProjectile = function(id) {
    var projectile;
    exports.projectiles.forEach(function(element, index, array) {
        if(element.id == id) {
            projectile = element;
        }
    });
    return projectile;
};

exports.removeProjectile = function(id) {
    physicSpace.removeBody(id);
    var indexToRemove = -1;
    exports.projectiles.forEach(function(element, index, array) {
        if(element.id == id) {
            indexToRemove = index;
        }
    });
    if(indexToRemove >= 0) {
        exports.projectiles.splice(indexToRemove, 1);
    }
};

exports.manageKeyboardInput = function(type, action, player) {
	if(action == 'up' || action == 'down' || action == 'right' || action == 'left') {
		var body = player.body;
		var force;
		var norme = 15;
		switch(action) {
			case 'up':
				force = new Force(0, -norme*3);
			break;
			case 'down':
				force = new Force(0, 0);
			break;
			case 'left':
				force = new Force(-norme*1.5, 0);
			break;
			case 'right':
				force = new Force(norme*1.5, 0);
			break;
		}
		if(type == 'down') {
			body.addForce(action, force);
		} else {
			body.removeForce(action);
		}
	}
};

exports.manageMouseInput = function (type, x, y, player) {
    if(type == 'down') {
        player.weapon.onTriggerPulled();
    } else if(type == 'up') {
        player.weapon.onTriggerReleased();
    } else if(type == 'move') {
        player.relativeCursorX = x;
        player.relativeCursorY = y;
    }
};













